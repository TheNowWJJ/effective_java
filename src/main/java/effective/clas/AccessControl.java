package effective.clas;

/**
 * 要使类和成员的可访问性最小化
 * 一个设计良好的模块和设计不好的模块，最重要的区分是这个模块对于其他模块而言，是否隐藏了内部的数据和其他的实现细节。
 * 模块之间只通过它们的API进行访问，一个模块不需要知道其他模块的内部工作情况。这就是封装！
 * <p>
 * 好处是
 * 1.可以解除  一个系统各个模块之间的耦合性，减轻了维护负担。
 * 2.虽然不会提高性能，但是它使得有效的性能调节成为可能。
 * 3.可以提高代码的可重用性
 * 4.降低了构建大型系统的风险。
 * <p>
 * 手段
 * <p>
 * 访问范围控制符
 * <p>
 * 建议：
 * 1.对于共有类的成员，当访问级别从包级私有变成保护级别时，会出现可访问性的巨大增加。受保护的成员应该少用。
 * 2.当你改写了父类中一个方法时，是无法降低该方法的访问级别的（那就不叫重写了），这样可确保子类的实例可以被用在任何可使用
 * 父类的场合。
 * 3.公有类应该尽可能少的使用公有变量。如果一个类是非final的，或者老是指向一个可变对象的final引用，那它一旦成为公有的，就
 * 无法对存储在这个变量中的值进行限制。因为公有的成员变量是线程不安全的（spring 单例模式就会产生这个问题）
 * 4.通过公有的静态final成员来暴露类的常量是可以的。但是其数据类型应该是java基本数据类型或者是一个非可变的对象的引用。
 * 虽然成员本身不可被修改，但是它指向的对象是可以被修改的。（静态数据常量见代码）
 * <p>
 * Created by wangjj on 16-3-27.
 */
public class AccessControl {

    /**
     * 数据VALUES引用是不可被更改的，但是数组VALUES中没有被赋值的index位置依然可以进行赋值操作。
     * 所以不能定义公有的静态final数组成员，这也是常见安全漏洞的根源
     */
    public static final String[] VALUES = new String[5];

    public static void main(String[] args) {
        System.out.println("修改前");
        VALUES[0] = "1";
        VALUES[1] = "2";
        for (String v : VALUES) {
            System.out.println(v);
        }
        System.out.println("修改后");
        VALUES[2] = "3";
        for (String v : VALUES) {
            System.out.println(v);
        }
    }

}
